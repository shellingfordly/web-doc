"use strict";(self.webpackChunkweb_doc=self.webpackChunkweb_doc||[]).push([[692],{9244:(e,n,a)=>{a.r(n),a.d(n,{data:()=>s});const s={key:"v-f8aeace8",path:"/frame/react/useEffect.html",title:"",lang:"en-US",frontmatter:{categories:["frame","react"]},excerpt:"",headers:[{level:2,title:"useEffect",slug:"useeffect",children:[]}]}},5108:(e,n,a)=>{a.r(n),a.d(n,{default:()=>u});const s=(0,a(6252).uE)('<h2 id="useeffect" tabindex="-1"><a class="header-anchor" href="#useeffect" aria-hidden="true">#</a> useEffect</h2><p>在 useEffect 中进行异步获取数据，并使用 useState 设置数据时会导致内存泄露</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Warning: Can&#39;t perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in a useEffect cleanup function.\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ul><li>原因：由于异步的 setState，如果此时此组件已经被销毁，但当异步结束时会去执行回调中 setState，改变数据的状态，因此造成了内存泄漏的风险。</li><li>解决方法：需要在组件销毁时去清楚组件内部一些还在等待执行的回调 <ul><li>useEffect 的返回参数是一个函数，此函数会在组件被销毁时执行，因此可以提前定义一个变量 unmounted，当组件销毁时改变 unmounted 的状态，异步回调内部根据 unmounted 的状态来确定是否要操作数据</li></ul></li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>useEffect(() =&gt; {\n  let unmounted = false;\n  update(unmounted);\n  return () =&gt; {\n    unmounted = true;\n  };\n}, []);\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div>',5),t={},u=(0,a(3744).Z)(t,[["render",function(e,n){return s}]])},3744:(e,n)=>{n.Z=(e,n)=>{const a=e.__vccOpts||e;for(const[e,s]of n)a[e]=s;return a}}}]);