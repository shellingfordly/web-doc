"use strict";(self.webpackChunkweb_doc=self.webpackChunkweb_doc||[]).push([[7692],{9244:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e={key:"v-f8aeace8",path:"/frame/react/useEffect.html",title:"",lang:"en-US",frontmatter:{categories:["frame","react"]},excerpt:"",headers:[{level:2,title:"useEffect",slug:"useeffect",children:[]}],filePathRelative:"frame/react/useEffect.md",git:{updatedTime:1663579823e3,contributors:[{name:"shellingfordly",email:"shellingfordly@qq.com",commits:1}]}}},273:(n,s,a)=>{a.r(s),a.d(s,{default:()=>p});const e=(0,a(6252).uE)('<h2 id="useeffect" tabindex="-1"><a class="header-anchor" href="#useeffect" aria-hidden="true">#</a> useEffect</h2><p>在 useEffect 中进行异步获取数据，并使用 useState 设置数据时会导致内存泄露</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Warning: Can&#39;t perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in a useEffect cleanup function.\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ul><li>原因：由于异步的 setState，如果此时此组件已经被销毁，但当异步结束时会去执行回调中 setState，改变数据的状态，因此造成了内存泄漏的风险。</li><li>解决方法：需要在组件销毁时去清楚组件内部一些还在等待执行的回调 <ul><li>useEffect 的返回参数是一个函数，此函数会在组件被销毁时执行，因此可以提前定义一个变量 unmounted，当组件销毁时改变 unmounted 的状态，异步回调内部根据 unmounted 的状态来确定是否要操作数据</li></ul></li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> unmounted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n  <span class="token function">update</span><span class="token punctuation">(</span>unmounted<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    unmounted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div>',5),t={},p=(0,a(3744).Z)(t,[["render",function(n,s){return e}]])},3744:(n,s)=>{s.Z=(n,s)=>{const a=n.__vccOpts||n;for(const[n,e]of s)a[n]=e;return a}}}]);