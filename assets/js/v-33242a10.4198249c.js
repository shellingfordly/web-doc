"use strict";(self.webpackChunkweb_doc=self.webpackChunkweb_doc||[]).push([[178],{4770:(n,e,s)=>{s.r(e),s.d(e,{data:()=>a});const a={key:"v-33242a10",path:"/frame/vue/vue3/problem.html",title:"问题",lang:"en-US",frontmatter:{categories:["frame","vue","vue3"]},excerpt:"",headers:[{level:2,title:"getCurrentInstance",slug:"getcurrentinstance",children:[]},{level:2,title:"ctx",slug:"ctx",children:[]},{level:2,title:"proxy",slug:"proxy",children:[]},{level:2,title:"数据响应",slug:"数据响应",children:[{level:3,title:"某些特殊情况下，非响应式数据改变也能被页面响应",slug:"某些特殊情况下-非响应式数据改变也能被页面响应",children:[]}]},{level:2,title:"组件循环",slug:"组件循环",children:[]}]}},2305:(n,e,s)=>{s.r(e),s.d(e,{default:()=>b});var a=s(6252);const l=(0,a.uE)('<h1 id="问题" tabindex="-1"><a class="header-anchor" href="#问题" aria-hidden="true">#</a> 问题</h1><h2 id="getcurrentinstance" tabindex="-1"><a class="header-anchor" href="#getcurrentinstance" aria-hidden="true">#</a> getCurrentInstance</h2><blockquote><p>获取当前组件实例</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>import { getCurrentInstance } from &quot;vue&quot;;\nconst instance = getCurrentInstance();\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="ctx" tabindex="-1"><a class="header-anchor" href="#ctx" aria-hidden="true">#</a> ctx</h2><blockquote><p>当前组件的上下文，只能在开发环境下使用，生产环境下的 ctx 将访问不到，ctx 中包含了组件中由 ref 和 reactive 创建的响应式数据对象，以及 proxy 下的属性</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>const { ctx } = getCurrentInstance();\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ul><li><p>注意：在 setup 中不可以调用 getCurrentInstance().ctx 来获取组件内部数据，因为在 prod 模式会被干掉</p></li><li><p>原因：</p><ul><li>ctx 只是为了便于在开发模式下通过控制台检查</li><li>在 prod 模式是一个空对象</li></ul></li></ul>',8),t=(0,a._)("img",{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bff5eb65818408aa012a6fff86c2852~tplv-k3u1fbpfcp-watermark.image?imageslim",alt:"instance.ctx"},null,-1),r=(0,a.Uk)(" 图片来源"),i={href:"https://juejin.cn/post/6899432348266283022",target:"_blank",rel:"noopener noreferrer"},u=(0,a.Uk)("掘金 春去春又来"),p=(0,a.uE)('<h2 id="proxy" tabindex="-1"><a class="header-anchor" href="#proxy" aria-hidden="true">#</a> proxy</h2><blockquote><p>在开发环境以及生产环境下都能放到组件上下文对象（推荐）</p></blockquote><p>包含属性$attrs,$data,$el,$emit,$forceUpdate,$nextTick,$options,$parent,$props,$refs,$root,$slots,$watch</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>const { proxy } = getCurrentInstance();\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="数据响应" tabindex="-1"><a class="header-anchor" href="#数据响应" aria-hidden="true">#</a> 数据响应</h2><h3 id="某些特殊情况下-非响应式数据改变也能被页面响应" tabindex="-1"><a class="header-anchor" href="#某些特殊情况下-非响应式数据改变也能被页面响应" aria-hidden="true">#</a> 某些特殊情况下，非响应式数据改变也能被页面响应</h3><p>非响应式变量改变时页面是无法重新渲染的，如果在响应式数据改变的时候，改变了非响应式的变量，此时页面会同时重新渲染新数据。但是只限于数组和对象的改变，普通字符串不渲染。</p><h4 id="数组" tabindex="-1"><a class="header-anchor" href="#数组" aria-hidden="true">#</a> 数组</h4><ul><li>数组的 push/pop 或者是直接[index]赋值的方式都是会触发的</li></ul><p>template 代码</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code>&lt;div&gt;\n  &lt;button @click=&quot;push&quot;&gt;Push&lt;/button&gt;\n  &lt;ul&gt;\n    &lt;li v-for=&quot;item in list1&quot; :key=&quot;item&quot;&gt;{{ item }}&lt;/li&gt;\n  &lt;/ul&gt;\n  &lt;ul&gt;\n    &lt;li v-for=&quot;item in list2&quot; :key=&quot;item&quot;&gt;{{ item }}&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>ts 代码</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>setup(){\n const list1 = ref&lt;string[]&gt;([&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;]);\n  const list2 = [&quot;AAA&quot;, &quot;BBB&quot;, &quot;CCC&quot;];\n\n  function push() {\n    list1.value.push(&quot;ddd&quot;);\n    list2.push(&quot;DDD&quot;);\n  }\n\n  return { list1, list2, push }\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>点击 Push，页面同时渲染了 list1 和 list2</p><h4 id="对象" tabindex="-1"><a class="header-anchor" href="#对象" aria-hidden="true">#</a> 对象</h4><ul><li>对象的属性修改/新增也是会触发页面渲染的</li></ul><p>template 代码</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code>&lt;button @click=&quot;modify&quot;&gt;modify&lt;/button&gt;\n&lt;div&gt;{{ obj1 }}&lt;/div&gt;\n&lt;div&gt;{{ obj2 }}&lt;/div&gt;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>ts 代码</li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>setup(){\n  const obj1 = reactive({\n    key: &quot;obj1 key&quot;,\n  });\n  const obj2 = {\n    key: &quot;obj2 key&quot;,\n  };\n\n  function modify() {\n    obj1.key = &quot;modify obj1 key&quot;;\n    obj2.key = &quot;modify obj2 key&quot;;\n  }\n\n  return { obj1, obj2, modify };\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>点击修改 obj1 和 obj2 的 key 后，页面都渲染了</p><h4 id="字符串" tabindex="-1"><a class="header-anchor" href="#字符串" aria-hidden="true">#</a> 字符串</h4><ul><li>修改普通字符串后，页面没有渲染</li><li>数字/Boolean 和字符串的效果一样</li></ul><p>template 代码</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code>&lt;button @click=&quot;modify&quot;&gt;modify&lt;/button&gt;\n&lt;div&gt;value1 ====== {{ value1 }}&lt;/div&gt;\n&lt;div&gt;value2 ====== {{ value2 }}&lt;/div&gt;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>js 代码</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>setup() {\n  const value1 = ref(&quot;使用ref声明的value1&quot;);\n  let value2 = &quot;普通字符串value2&quot;;\n\n  function modify() {\n    value1.value = &quot;修改value1&quot;;\n    value2 = &quot;修改value2&quot;;\n  }\n\n  return { value1, value2, modify };\n},\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>点击修改后页面只有 ref 声明的变量重新渲染了，普通声明的变量并没有重新渲染</p><h2 id="组件循环" tabindex="-1"><a class="header-anchor" href="#组件循环" aria-hidden="true">#</a> 组件循环</h2><ul><li>当在给某组件循环需要在外层套 div/template ，但同时 div/template 会影响结构时，可以直接循环组件</li></ul><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code>&lt;Parent&gt;\n  &lt;Son v-for=&quot;item in list&quot; :data=&quot;item&quot; /&gt;\n&lt;/Parent&gt;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div>',31),c={},b=(0,s(3744).Z)(c,[["render",function(n,e){const s=(0,a.up)("OutboundLink");return(0,a.wg)(),(0,a.iD)(a.HY,null,[l,(0,a._)("p",null,[t,r,(0,a._)("a",i,[u,(0,a.Wm)(s)])]),p],64)}]])},3744:(n,e)=>{e.Z=(n,e)=>{const s=n.__vccOpts||n;for(const[n,a]of e)s[n]=a;return s}}}]);