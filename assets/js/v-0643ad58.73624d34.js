"use strict";(self.webpackChunkweb_doc=self.webpackChunkweb_doc||[]).push([[672],{2426:(n,e,s)=>{s.r(e),s.d(e,{data:()=>a});const a={key:"v-0643ad58",path:"/frame/react/memo.html",title:"memo",lang:"en-US",frontmatter:{categories:["frame","react"]},excerpt:"",headers:[{level:2,title:"React.memo()",slug:"react-memo",children:[]},{level:2,title:"useMemo()",slug:"usememo",children:[]}]}},1239:(n,e,s)=>{s.r(e),s.d(e,{default:()=>u});var a=s(6252);const r=(0,a.uE)('<h1 id="memo" tabindex="-1"><a class="header-anchor" href="#memo" aria-hidden="true">#</a> memo</h1><h2 id="react-memo" tabindex="-1"><a class="header-anchor" href="#react-memo" aria-hidden="true">#</a> React.memo()</h2><ul><li>PureComponent 是对 class 组件的性能优化，每次会对 props 进行浅比较，同时还可以在 shouldComponentUpdate 中进行深层次的控制</li><li>React.memo 这个 HOC 是对 Function Component 提供的，areEqual 参数相当于 shouldComponentUpdate 的作用</li></ul><ol><li>使用方式</li></ol><ul><li>areEqual 判断两次 props 是否不同，不传 areEqual 则对 props 进行浅比较</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function MyComponent(props) {\n  /* 使用 props 渲染 */\n}\nfunction areEqual(prevProps, nextProps) {\n  /*\n  如果把 nextProps 传入 render 方法的返回结果与\n  将 prevProps 传入 render 方法的返回结果一致则返回 true，\n  否则返回 false\n  */\n}\nexport default React.memo(MyComponent, areEqual);\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><ol start="2"><li>性能优化</li></ol><ul><li>Parent Component</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>// Parent Component\nexport default (props = {}) =&gt; {\n  const [count1, setCount1] = useState(0);\n  const [count2, setCount2] = useState(0);\n\n  return (\n    &lt;&gt;\n      &lt;button onClick={()=&gt;{setCount1(count1+1)})}&gt;count1: {count} &lt;/button&gt;\n      &lt;button onClick={()=&gt;{setCount2(count2+1)}}&gt;count2: {number} &lt;/button&gt;\n      &lt;Son  count1={count1} count2={count2} /&gt; &lt;hr /&gt;\n      &lt;MemoSon count1={count1} count2={count2} /&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><ul><li>Son Component</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>export default (props = {}) =&gt; {\n  console.log(`Son Component`);\n  return &lt;div&gt;count1: {props.count1}&lt;/div&gt;;\n};\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>MemoSon Component</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>const isEqual = (prevProps, nextProps) =&gt; {\n  if (prevProps.count2 !== nextProps.count2) {\n    return false;\n  }\n  return true;\n};\n\nexport default memo((props = {}) =&gt; {\n  console.log(`--- memo re-render ---`);\n  return &lt;div&gt;count2: {props.count2}&lt;/div&gt;;\n}, isEqual);\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>总结：count1、count2 的变化都会导致 Son 组件的重新渲染，而 MemoSon 只有在 count2 发生变化时才会重新渲染</p><h2 id="usememo" tabindex="-1"><a class="header-anchor" href="#usememo" aria-hidden="true">#</a> useMemo()</h2><p>React.memo 始终包装整个组件，并且需要手动比较具体的 props，而某些时候我们只想要 template 进行 re-render，而不是整个组件 re-render，useMemo 可以实现局部 Pure 功能</p><ol><li>基本用法</li></ol><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>返回一个 memoized 值，只有当依赖项[a,b]发生变化时，才会重新计算这个 memoized 值，否则不会重新渲染。</p><p>传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo。</p><p>如果没有提供依赖项[a,b]，则每次都会重新计算 memoized 值</p><ol start="2"><li>性能优化</li></ol><ul><li>UseMemoSon Component</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>export default (props = {}) =&gt; {\n  console.log(`--- component re-render ---`);\n  return useMemo(() =&gt; {\n    console.log(`--- useMemo re-render ---`);\n    return (\n      &lt;div&gt;\n        &lt;p&gt;count2: {props.count2}&lt;/p&gt;\n      &lt;/div&gt;\n    );\n  }, [props.count2]);\n};\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>总结：useMemo 包装的是 return 部分的渲染逻辑，当 count1 发生变化是，会触发函数组件的重新渲染，打印 component re-render，但不会触发 return 返回函数的 re-render，只有在 count2 发生变化时才会打印 useMemo re-render</p>',25),l=(0,a.Uk)("感谢 "),p={href:"https://zhuanlan.zhihu.com/p/105940433",target:"_blank",rel:"noopener noreferrer"},t=(0,a.Uk)("ai 哟"),o={},u=(0,s(3744).Z)(o,[["render",function(n,e){const s=(0,a.up)("OutboundLink");return(0,a.wg)(),(0,a.iD)(a.HY,null,[r,(0,a._)("ul",null,[(0,a._)("li",null,[l,(0,a._)("a",p,[t,(0,a.Wm)(s)])])])],64)}]])},3744:(n,e)=>{e.Z=(n,e)=>{const s=n.__vccOpts||n;for(const[n,a]of e)s[n]=a;return s}}}]);