## 浏览器

### 思考

- 浏览器解析完 dom 树之后做什么
- 浏览器将 html 展示到页面做了什么
- 回流和重绘
  - 什么样的情况下触发回流
  - 什么样的情况下触发重绘

### 浏览器渲染过程

1. 解析 HTML，生成 DOM 树，解析 CSS，生成 CSSOM 树
2. 将 DOM 树和 CSSOM 树结合，生成渲染树（render tree）
3. reflow（回流）：根据生成的渲染树，进行回流，得到节点的几何信息（位置、大小）
4. painting（重绘）： 根据渲染树以及回流的到的几何信息，得到节点的绝对像素
5. display：将像素发送给 GPU，展示在页面上（比如 GPU 将多个合成层合并成同一层）

#### 构建渲染树

1. 从 DOM 树的根节点开始遍历每个可见节点
2. 对每个可见节点，找到 CSSOM 树种对应规则，并应用
3. 根据每个可见节点以及对应的样式，组成渲染树

- 非可见节点
  - script、meta、link
  - display: none 隐藏的节点
- 可见节点
  - visibility/opacity 隐藏的节点还是会显示到渲染树上
- 渲染树只有可见节点

- 问题
  - 那么非可见节点如何挂载到渲染树上
  - 添加/删除元素，以及元素的 display 显隐是怎么处理渲染树的，有什么区别

### 回流和重绘

#### 回流

- 当 render tree 的一部分因为元素的规模尺寸、布局、隐藏等改变时需要重新构建，这就是回流
- 每个页面至少需要一次回流，在页面第一次加载的时候，一定会发生回流，因为要构建 render tree
  - render tree 是 dom tree 和 css tree 组合构建而成
- 在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树
- 完成回流后，浏览器会重新绘制受影响的部分到页面上，此过程为重回

- 引起回流的因素
  - 添加删除可见 dom
  - 元素位置改变
  - 元素尺寸改变（边框、边距、填充、宽度、高度）
  - 内容发生变化，
    - 文本变化
    - 图片被不同尺寸的图片替换
    - input 框输入文字
    - css3 动画
  - 激活 CSS 伪类，比如 hover
  - 操作 class 属性
  - 计算 offset 等等属性
  - 设置 style 属性值
  - 页面一开始渲染时
  - 浏览器窗口尺寸变化（因为回流是根据视口大小来计算元素位置和大小的）
  - 改变字体
  - 增加或者移除样式表

#### 重绘

- 通过构建渲染树和回流阶段，得到了可见节点的样式和具体几何信息（位置、大小），把渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫重绘节点

- 当 render tree 中的一些元素需要更新属性，比如影响元素外观、风格此类不会影响布局的属性，浏览器会重新绘制这个元素，这个过程就是重绘

#### 区别

- 回流必会引起重绘，而重绘不一定会引起回流
  - 比如颜色改变等等
- 当页面布局和几何属性改变时就需要回流
  - 比如操作 dom、改变位置等等
- 而重绘是视觉效果变化引起
  - 比如修改 color、background

#### 浏览器优化机制

根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如出现滚动条和修改根节点

每次重排都会造成额外的计算消耗，浏览器会通过队列化修改并批量执行来优化重排过程。将修改操作放入队列里，直到过了一段时间或操作达到了一个阈值，再清空队列。

- 当获取布局信息时会强制队列刷新
- offsetTop、offsetLeft、offsetWidth、offsetHeight
- scrollTop、scrollLeft、scrollWidth、scrollHeigh
- clientTop、clientLeft、clientWidth、clientHeight
- getComputedStyle()
- getBoundingClientRect

#### 减少重绘和重排

- 由于重绘和重排代价比较高，所以最好减少其发生的次数，可以通过合并多次对 DOM 的样式修改，一次性处理掉
  - 使用 cssText
  - 通过修改 css 的 class 来改变元素样式
- 批量修改 DOM
  - 使元素脱离文档流，对其进行多次操作，再将元素带回文档
- 脱离文档流
  - 隐藏元素 --> 应用修改 --> 重新显示
  - 使用文档片段（document fragment）构建一个子树，再把它拷贝回文档
  - 将原始元素拷贝到一个脱离文档的节点中，修改完再替换原始元素
- 避免 table 布局

```js
// 隐藏元素进行修改
ul.style.display = "none";
handleUlAction(ul, data);
ul.style.display = "block";

// 文档片段修改
const fragment = document.createDocumentFragment();
appendDataToElement(fragment, data);
ul.appendChild(fragment);

// 拷贝修改
const clone = ul.cloneNode(true);
appendDataToElement(clone, data);
ul.parentNode.replaceChild(clone, ul);
```

#### 问题

1. 添加删除不可见（display: none）元素会不会引起回流？

- 自我感觉是不会的，因为 display 的元素不是可见元素，不会在被挂在渲染树上，因为删除/添加都不会引起渲染树的变化，不会引起回流。而显示隐藏元素只会触发重绘，不会触发回流，因此不管怎么操作不可见元素都不会引起回流重绘，只有在显示的时候、或者隐藏的时候触发重绘。

2. 滚动条会触发回流吗

- 如果使用了 fixed 定位的元素，其 dom 是相对于浏览器的窗口进行定位的，没滚动一点，元素就会重新计算定位高度位置，导致触发回流。fixed 定位只会对自身元素进行渲染，不会影响身边的 DOM

3. 修改根节点会触发回流重绘吗

- 从上述资料来看，修改根节点会触发回流重绘这个问题不够严谨，看修改的是什么属性导致可能触发回流，也可能只触发重绘
